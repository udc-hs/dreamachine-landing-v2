<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dreamachine</title>
  <style>
    /* Ensure fullscreen layout */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    /* Common styles for both videos */
    .video-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      pointer-events: none;
    }

    /* The top video has a circular reveal effect with feathered edges */
    .top-video {
      position: absolute;
      -webkit-mask-image: radial-gradient(circle, rgba(0,0,0,1) 50%, rgba(0,0,0,0) 100%);
      mask-image: radial-gradient(circle, rgba(0,0,0,1) 50%, rgba(0,0,0,0) 100%);
      transition: mask-image 0.05s ease-out, -webkit-mask-image 0.05s ease-out;
    }

    /* Clickable Logo */
    .logo {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80vw;  /* Responsive: 80% of viewport width */
      max-width: 1000px;  /* Prevents the logo from becoming too large */
      height: auto;
      cursor: pointer;
      z-index: 10; /* Ensures it's above videos */
    }

    /* Loading counter at bottom right */
    .loading-counter {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 1.2rem;
      z-index: 20;
      opacity: 1;
      transition: opacity 0.5s ease-in-out;
    }

    /* Video fade-in effect */
    .video-container {
      opacity: 0;
      transition: opacity 1s ease-in-out;
    }

    .video-container.loaded {
      opacity: 1;
    }
  </style>
</head>
<body>

  <!-- Bottom Video -->
  <video id="bottomVideo" class="video-container" muted playsinline loop preload="metadata">
    <source src="https://freight.cargo.site/m/L2190992256300586244793696638090/AI-BLACK.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>

  <!-- Top Video (initially covering the bottom one) -->
  <video id="topVideo" class="video-container top-video" muted playsinline loop preload="metadata">
    <source src="https://freight.cargo.site/m/A2191010521805399430148968010890/inverted-depth.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>

  <!-- Clickable Logo -->
  <a href="mailto:hello@thedreamachine.com?subject=Portfolio%20Request&body=Hello,%20I%20would%20like%20to%20know%20more%20about...">
    <img src="https://freight.cargo.site/t/original/i/R2192464133004486997848030041226/DM_Logo_for_web_V01-no-bottom-bit.png" alt="Logo" class="logo">
  </a>

  <!-- Loading counter -->
  <div id="loadingCounter" class="loading-counter">Loading: 0%</div>

  <script>
    const topVideo = document.getElementById("topVideo");
    const bottomVideo = document.getElementById("bottomVideo");
    const loadingCounter = document.getElementById("loadingCounter");

    let revealRadius = 50; // Size of the fully revealed area (hard edge)
    let featherRadius = 300; // Additional soft feathered edge
    
    // Loading progress tracking
    let topVideoLoaded = false;
    let bottomVideoLoaded = false;
    let loadingProgress = 0;
    let videosStarted = false;

    // Update loading counter display
    function updateLoadingCounter(progress) {
      loadingProgress = progress;
      loadingCounter.textContent = `Loading: ${Math.round(progress)}%`;
      
      // Hide counter when loading is complete
      if (progress >= 100) {
        setTimeout(() => {
          loadingCounter.style.opacity = '0';
        }, 500);
      }
    }

    // Check if both videos are ready and start playback
    function checkVideosReady() {
      if (topVideoLoaded && bottomVideoLoaded && !videosStarted) {
        videosStarted = true;
        updateLoadingCounter(100);
        
        // Small delay to ensure everything is ready
        setTimeout(() => {
          startSyncedPlayback();
        }, 100);
      }
    }

    // Start synchronized video playback with fade-in
    function startSyncedPlayback() {
      // Reset both videos to start
      topVideo.currentTime = 0;
      bottomVideo.currentTime = 0;

      // Play both videos simultaneously
      Promise.all([topVideo.play(), bottomVideo.play()])
        .then(() => {
          console.log("Both videos started in sync");
          
          // Fade in videos
          topVideo.classList.add('loaded');
          bottomVideo.classList.add('loaded');
        })
        .catch(error => {
          console.error("Error playing videos:", error);
          // Fallback: still show videos even if autoplay fails
          topVideo.classList.add('loaded');
          bottomVideo.classList.add('loaded');
        });
    }

    // Video loading event handlers
    function onVideoCanPlay(video, isTop) {
      if (isTop) {
        topVideoLoaded = true;
      } else {
        bottomVideoLoaded = true;
      }
      
      // Update progress (50% per video)
      const progress = (topVideoLoaded ? 50 : 0) + (bottomVideoLoaded ? 50 : 0);
      updateLoadingCounter(progress);
      
      checkVideosReady();
    }

    // Enhanced loading progress tracking
    function onVideoProgress(video, isTop) {
      if (video.buffered.length > 0) {
        const bufferedEnd = video.buffered.end(video.buffered.length - 1);
        const duration = video.duration;
        if (duration > 0) {
          const progressPercent = (bufferedEnd / duration) * 50; // 50% per video
          const currentProgress = isTop ? 
            progressPercent + (bottomVideoLoaded ? 50 : (bottomVideo.buffered.length > 0 ? (bottomVideo.buffered.end(bottomVideo.buffered.length - 1) / bottomVideo.duration) * 50 : 0)) :
            progressPercent + (topVideoLoaded ? 50 : (topVideo.buffered.length > 0 ? (topVideo.buffered.end(topVideo.buffered.length - 1) / topVideo.duration) * 50 : 0));
          
          updateLoadingCounter(Math.min(currentProgress, 100));
        }
      }
    }

    // Set up video loading listeners
    topVideo.addEventListener("canplay", () => onVideoCanPlay(topVideo, true));
    bottomVideo.addEventListener("canplay", () => onVideoCanPlay(bottomVideo, false));
    
    topVideo.addEventListener("progress", () => onVideoProgress(topVideo, true));
    bottomVideo.addEventListener("progress", () => onVideoProgress(bottomVideo, false));

    // Fallback loading detection
    topVideo.addEventListener("loadeddata", () => {
      if (!topVideoLoaded) {
        onVideoCanPlay(topVideo, true);
      }
    });
    
    bottomVideo.addEventListener("loadeddata", () => {
      if (!bottomVideoLoaded) {
        onVideoCanPlay(bottomVideo, false);
      }
    });

    // Restart videos in sync when they end (backup to loop attribute)
    function restartVideos() {
      if (videosStarted) {
        topVideo.currentTime = 0;
        bottomVideo.currentTime = 0;
      }
    }

    // Sync playback speeds (prevents drift over time)
    function matchPlaybackRates() {
      if (videosStarted) {
        bottomVideo.playbackRate = topVideo.playbackRate;
      }
    }

    // Sync playback rates continuously
    topVideo.addEventListener("ratechange", matchPlaybackRates);

    // Ensure both videos restart together (backup to loop)
    topVideo.addEventListener("ended", restartVideos);
    bottomVideo.addEventListener("ended", restartVideos);

    // Apply radial mask based on coordinates
    function updateMask(x, y) {
      const maskStyle = `radial-gradient(circle ${revealRadius + featherRadius}px at ${x}px ${y}px,
                          rgba(0,0,0,1) ${revealRadius}px,
                          rgba(0,0,0,0) ${revealRadius + featherRadius}px)`;
      topVideo.style.maskImage = maskStyle;
      topVideo.style.webkitMaskImage = maskStyle;
    }

    // Mouse movement effect for reveal with a hard center and feathered edges
    document.addEventListener("mousemove", (event) => {
      updateMask(event.clientX || 0, event.clientY || 0);
    });

    // Touch movement support for mobile devices
    document.addEventListener("touchmove", (event) => {
      const touch = event.touches[0];
      if (touch) {
        updateMask(touch.clientX, touch.clientY);
      }
    });

    // Fallback timer in case loading events don't fire properly
    setTimeout(() => {
      if (!videosStarted) {
        console.log("Fallback: Starting videos after timeout");
        // Force mark as loaded and start
        topVideoLoaded = true;
        bottomVideoLoaded = true;
        checkVideosReady();
      }
    }, 10000); // 10 second fallback

    // Initialize loading counter
    updateLoadingCounter(0);

  </script>

</body>
</html>
